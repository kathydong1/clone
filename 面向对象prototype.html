<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script>
			/*
			 *new：先运行-返回值
			 *      new之后是个对象，报错
			 prototype:原型，任意一个函数的属性，属性值是object
			 -proto-原型链
			 
			 
			 function既是构造函数又是实例化对象
			 
			 函数是既有原型又有原型链
			 对象身上没有原型prototype，只有原型链-proto-
			       
			 实例化对象的原型链==构造函数的原型
			 
			 优先级：
			      实例化对象上就有的方法>构造函数的原型下的方法>object下的原型
			      对象找原型链-》构造函数的原型--构造函数原型下的原型链--构造函数下object的原型
			 
			 
			 
			 "实例化对象下的-proto-"---"对象原型链下的constructor"
			 ---"构造函数原型prototype"---"构造函数原型先的原型链__proto__"
			 ---"constructor"---"prototype"
              
              
                         构造函数的原型永远是给实例化对象使用的：
                                函数是一个特殊的实例化对象(是Function下的一个实例化对象function Function())，
                                看调用角度了，如果是fn.say的话，是走自身原型链-proto-；
                              
			 
			 
			 
			 * */
			//小例子1
				function fn(name){
					this.name=name;
//					this.say=function(){
//					   alert('fn上的'+this.name)
//				    }
				}
			
				fn.prototype.say=function(){
					alert('构造函数原型上的'+this.name)
				}
				Function.prototype.say=function(){
				    alert('object上的'+this.name)
		     	}
				Object.prototype.say=function(){
				    alert('object上的'+this.name)
		     	}
				var f1=new fn('小白')
				  console.log(f1)                        //查找方式：在f1上的原型链上找，没有的话找fn的原型
				
				f1.say()
				//fn
				fn.say()//fn现在是Function上的实例化对象						//console.log(f1)//对象身上只有原型链
				console.dir(fn)							//console.dir(fn)//对象身上即有原型，又有原型链
//			    fn.say();
//			    console.dir(fn)
			
			

			
			
			
			
			
			
			
		</script>
	</body>
</html>
